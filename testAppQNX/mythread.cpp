#include "mythread.h"
#include <QtCore/qmath.h>
#include <QTime>
#include <QFile>
#include <QTextStream>
#include <time.h>

#include <qtextcodec>
#include <qmessagebox.h>
#include <unistd.h>
#include <QTime>

#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <time.h>
#include <errno.h>
#include <signal.h>
#include <unistd.h>
#include <sys/siginfo.h>
#include <sys/neutrino.h>
#include <sys/netmgr.h>
#include <hw/inout.h>
#include <sched.h>
#include "PulseGeneratorController.h"


MyThread::MyThread()
{
}


#define CODE_TIMER      2
#define PERIOD			1000

int const MyThread::activeChannels[] = {0, 20, 1, 21, 2, 23}; //Channels: 0 - positive X, 20 - negative X; 1 - positive Y, 21 - Negative Y; 2 - positive Z, 23 - negative Z;

void MyThread::run()
{
    setPriority(QThread::HighPriority);
    int rcvid;
    int chid;
    struct _pulse msg;
    timer_t timerid;
    struct sigevent evt;
    struct itimerspec timer;
    int coid;
    struct _clockperiod clk_per_old;
    struct _clockperiod clk_per_new;
    clk_per_new.fract = 0;
    clk_per_new.nsec = 100000;
    int quantity[6] = {0,0,0,0,0,0};
    //int quantity = 0;

    //********************************************************************
    //*******     timer       ********************************************
    //********************************************************************

    //create a channel for timer pulse reception
    if ( (chid = ChannelCreate(0)) == -1 )
    {
        //ui.teLog->append( "error creating a channel!\n");
        //exit(EXIT_FAILURE);
    }


    // create a connection to ourselves
    coid = ConnectAttach(ND_LOCAL_NODE, 0,chid,0,0);
    if (coid == -1)
    {
        //ui.teLog->append( tr("error conecting to a channel! %1\n").arg(strerror( errno )) );
        //exit(EXIT_FAILURE);
    }
    // set up pulse event to be generated by timer
    SIGEV_PULSE_INIT(&evt,coid,/*SIGEV_PULSE_PRIO_INHERIT*/getprio(0),CODE_TIMER,0);
    // create timer and anchor event to it
    if ( timer_create(CLOCK_REALTIME,&evt, &timerid) == -1)
    {
        //ui.teLog->append( "error creating a timer!\n");
        //exit(EXIT_FAILURE);
    }
    //setup timer delay and period
    timer.it_value.tv_sec = 0;
    timer.it_value.tv_nsec = PERIOD*5000;
    timer.it_interval.tv_sec = 0;
    timer.it_interval.tv_nsec = PERIOD*5000;

    // set thread privelege level to allow port IO operations
    if (ThreadCtl(_NTO_TCTL_IO, 0) == -1)
    {
       // ui.teLog->append( "Couldn't set proper thread privelege level!\n");
        //exit(EXIT_FAILURE);
    }

    // adjust clock period
    clk_per_new.fract = 0;
    clk_per_new.nsec = 100000;

    if ( ClockPeriod(CLOCK_REALTIME, &clk_per_new, &clk_per_old, 0) == -1)
    {
        //ui.teLog->append( " Couldn't set clock period!\n");
        //exit(EXIT_FAILURE);
    }
    //ui.teLog->append( tr("Clock period: old = %1 nsec; new = %2 nsec\n").arg(clk_per_old.nsec).arg(clk_per_new.nsec) );
    //qApp->processEvents();
    // start timer
    timer_settime(timerid,0,&timer, NULL);

    //********************************************************************
    //*******     timer       ********************************************
    //********************************************************************


    //********************************************************************
    //*******  Pulse Generator Controller  *******************************
    //********************************************************************
    boardController.setPortRw(&prw);
    boardController.setBaseAddress(0x1E0);
    for(int i=0; i<6; i++ ){
        boardController.writePulseTime(i, 30.0);
        boardController.writePeriod(i, 0.20);//?
        boardController.writeQuantity(i, 0);//quantity);
        boardController.writeInversion(i, 1);
        boardController.writeContinuity(i, 0);
    }

    //********************************************************************
    //*******  Pulse Generator Controller  *******************************
    //********************************************************************


    double wx = 0.0;
    int z = 0;
    int t1753 = 0;
    //Trying to open PCI's
    if(PCI1753_0.open(0)== 0){
        sendMsgToConsole("PCI1753 was opened!");
        PCI1753_0.setDirection(4, 0);
    }
    else
        sendMsgToConsole("Error: I can't open 1753");

    if (PCI1713_3.open(3) == 0)
        sendMsgToConsole("PCI1713_3 was opened!");
    else
        sendMsgToConsole("Error: I can't open 1713_3");


    sendMsgToConsole("TESTING WAS LAUNCHED!");

    for(double t = 0.0;;)

        {
        for(int i=0; i<7; i++ )
            boardController.writeQuantity(i, quantity[i]); //40 - 0ch(green), 42 - 1ch


        rcvid = MsgReceivePulse(chid, &msg,sizeof(msg),NULL );//get event from QNX to block thread
//******start new clk****************************************************
        boardController.startAll();
        reload_PCI1713();
        if(double(data[0])>2.5 && data[1]<2.5)
            z = 1;
        else if(double(data[1])>2.5 && data[0]<2.5)
            z = -1;
        else
            z = 0;

//*************control timer********************************************
        switch(int(t1753)){
            case (0):
                PCI1753_0.writePin(26, 1);
                t1753=double(PCI1753_0.readPin(26));
                break;
            case (1):
                PCI1753_0.writePin(26, 0);
                t1753=double(PCI1753_0.readPin(26));
                break;
        }
//*************control timer********************************************
        switch(z)
        {
        case (1)    : wx =  0.011*0.05 + wx; break;
        case (-1)   : wx = -0.011*0.05 + wx; break;
        case (0)    : wx = wx; break;
        }


        if (wx>0.0){
            quantity[0]=static_cast<int>(wx/0.0000304+0.5);
            quantity[1]=0;}
        else if(wx<0.0){
            quantity[1]=static_cast<int>((-wx)/0.0000304+0.5);
            quantity[0]=0;}
        else{
            quantity[0]=0;
            quantity[1]=0;}
        emit send(wx, t);
        emit sendinfo(data[0], data[1], z, quantity[0], t);
        t=t+0.05;
        }
}

void MyThread::reload_PCI1713(){
    for(int i=0; i<6; i++)
        data[activeChannels[i]]=PCI1713_3.read(i, 3);
}
