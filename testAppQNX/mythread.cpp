#include "mythread.h"
#include <QtCore/qmath.h>
#include <QTime>
#include <QFile>
#include <QTextStream>
#include <time.h>

#include <qtextcodec>
#include <qmessagebox.h>
#include <unistd.h>
#include <QTime>

#include <stdlib.h>
#include <stdio.h>
#include <stdint.h>
#include <string.h>
#include <time.h>
#include <errno.h>
#include <signal.h>
#include <unistd.h>
#include <sys/siginfo.h>
#include <sys/neutrino.h>
#include <sys/netmgr.h>
#include <hw/inout.h>
#include <sched.h>
#include "PulseGeneratorController.h"


MyThread::MyThread()
{
}


#define CODE_TIMER      2
#define PERIOD			1000
#define CLK             0.005
int const MyThread::activeChannels[] = {0, 20, 1, 21, 2, 23}; //Channels: 0 - positive X, 20 - negative X; 1 - positive Y, 21 - Negative Y; 2 - positive Z, 23 - negative Z;

void MyThread::run()
{
    setPriority(QThread::HighPriority);
    int rcvid;
    int chid;
    struct _pulse msg;
    timer_t timerid;
    struct sigevent evt;
    struct itimerspec timer;
    int coid;
    struct _clockperiod clk_per_old;
    struct _clockperiod clk_per_new;
    clk_per_new.fract = 0;
    clk_per_new.nsec = 100000;
    int quantity[6] = {0,0,0,0,0,0};
    double obs_er = 0.0; //Observational error

    //
    double w[] = {0.0, 0.0,  0.0};
    double R0 = 0.0, R1 = 0.0, R2 = 0.0, R3 = 0.0;
    double P0 = 0.0, P1 = 0.0, P2 = 0.0, P3 = 0.0;
    double SP = 0.0, SR = 0.0;
    double Q0 = 0.0, Q1 = 0.0, Q2 = 0.0, Q3 = 0.0;
    //int quantity = 0;

    //********************************************************************
    //*******     timer       ********************************************
    //********************************************************************

    //create a channel for timer pulse reception
    if ( (chid = ChannelCreate(0)) == -1 )
    {
        //ui.teLog->append( "error creating a channel!\n");
        //exit(EXIT_FAILURE);
    }


    // create a connection to ourselves
    coid = ConnectAttach(ND_LOCAL_NODE, 0,chid,0,0);
    if (coid == -1)
    {
        //ui.teLog->append( tr("error conecting to a channel! %1\n").arg(strerror( errno )) );
        //exit(EXIT_FAILURE);
    }
    // set up pulse event to be generated by timer
    SIGEV_PULSE_INIT(&evt,coid,/*SIGEV_PULSE_PRIO_INHERIT*/getprio(0),CODE_TIMER,0);
    // create timer and anchor event to it
    if ( timer_create(CLOCK_REALTIME,&evt, &timerid) == -1)
    {
        //ui.teLog->append( "error creating a timer!\n");
        //exit(EXIT_FAILURE);
    }
    //setup timer delay and period
    timer.it_value.tv_sec = 0;
    timer.it_value.tv_nsec = PERIOD*5000;
    timer.it_interval.tv_sec = 0;
    timer.it_interval.tv_nsec = PERIOD*5000;

    // set thread privelege level to allow port IO operations
    if (ThreadCtl(_NTO_TCTL_IO, 0) == -1)
    {
       // ui.teLog->append( "Couldn't set proper thread privelege level!\n");
        //exit(EXIT_FAILURE);
    }

    // adjust clock period
    clk_per_new.fract = 0;
    clk_per_new.nsec = 100000;

    if ( ClockPeriod(CLOCK_REALTIME, &clk_per_new, &clk_per_old, 0) == -1)
    {
        //ui.teLog->append( " Couldn't set clock period!\n");
        //exit(EXIT_FAILURE);
    }
    //ui.teLog->append( tr("Clock period: old = %1 nsec; new = %2 nsec\n").arg(clk_per_old.nsec).arg(clk_per_new.nsec) );
    //qApp->processEvents();
    // start timer
    timer_settime(timerid,0,&timer, NULL);

    //********************************************************************
    //*******     timer       ********************************************
    //********************************************************************


    //********************************************************************
    //*******  Pulse Generator Controller  *******************************
    //********************************************************************
    boardController.setPortRw(&prw);
    boardController.setBaseAddress(0x1E0);
    for(int i=0; i<6; i++ ){
        boardController.writePulseTime(i, 3.0);
        boardController.writePeriod(i, 0.05);//?
        boardController.writeQuantity(i, 3);//quantity);
        boardController.writeInversion(i, 1);
        boardController.writeContinuity(i, 0);
    }

    //********************************************************************
    //*******  Pulse Generator Controller  *******************************
    //********************************************************************



    int z[] = {0, 0, 0};
    int t1753 = 0;
    double lastime=0.0;
    //Trying to open PCI's
    if(PCI1753_0.open(0)== 0){
        sendMsgToConsole("PCI1753 was opened!");
        PCI1753_0.setDirection(4, 0);
    }
    else
        sendMsgToConsole("Error: I can't open 1753");

    if (PCI1713_3.open(3) == 0)
        sendMsgToConsole("PCI1713_3 was opened!");
    else
        sendMsgToConsole("Error: I can't open 1713_3");


    sendMsgToConsole("TESTING WAS LAUNCHED!");

    for(double t = 0.0;;)
        {
        for(int i=0; i<7; i++ )
            boardController.writeQuantity(i, quantity[i]); //40 - 0ch(green), 42 - 1ch


        rcvid = MsgReceivePulse(chid, &msg,sizeof(msg),NULL );//get event from QNX to block thread
//******start new clk****************************************************

        boardController.startAll();
        reload_PCI1713();

//*************check timer********************************************
        switch(int(t1753)){
            case (0):
                PCI1753_0.writePin(26, 1);
                t1753=double(PCI1753_0.readPin(26));
                break;
            case (1):
                PCI1753_0.writePin(26, 0);
                t1753=double(PCI1753_0.readPin(26));
                break;}
//*************check timer********************************************
        for (int k = 0; k<3; k++){
            if(double(data[k*2])>2.5 && data[k*2+1]<2.5)
                z[k] = 1;
            else if(double(data[k*2+1])>2.5 && data[k*2]<2.5)
                z[k] = -1;
            else
                z[k] = 0;



            switch(z[k])
            {
            case (1)    : w[k] =  0.011*0.005 + w[k]; break;
            case (-1)   : w[k] = -0.011*0.005 + w[k]; break;
            case (0)    : w[k] = w[k]; break;
            }

            if (w[k]>0.0){
                quantity[k*2]=static_cast<int>(w[k]*0.005/0.0000304+obs_er);
                quantity[k*2+1]=0;
                obs_er = (w[k]*0.005/0.0000304+obs_er)-quantity[k*2];}
            else if(w[k]<0.0){
                quantity[k*2+1]=static_cast<int>((-w[k])*0.005/0.0000304+obs_er);
                quantity[k*2]=0;
                obs_er =(w[k]*0.005/0.0000304+obs_er)-quantity[k*2+1];
                quantity[k*2+1]=-quantity[k*2+1];}
            else{
                quantity[k*2]=0;
                quantity[k*2+1]=0;}


        }


        if(t-lastime>0.01){
            emit send(w[0], w[1], w[2], t);
            emit sendinfo(data[2], data[3], t);
            emit sendf(w[0], Q0, Q1, t);
            lastime=t;
        }

        P1 = w[0]*0.5*CLK;
        P2 = w[0]*0.5*CLK;
        P3 = w[0]*0.5*CLK;

        SP = P1*P1 + P2*P2 + P3*P3;
        SR = R0*R0 + R1*R1 + R2*R2 + R3*R3;

        P0 = (3-SP-SR)*0.5;

        Q0 = R0*P0 - R1*P1 - R2*P2 - R3*P3;
        Q1 = R0*P1 + R1*P0 + R2*P3 - R3*P2;
        Q2 = R0*P2 + R2*P0 + R3*P1 - R1*P3;
        Q3 = R0*P3 + R3*P0 + R1*P2 - R2*P1;

        R0 = Q0;
        R1 = Q1;
        R2 = Q2;
        R3 = Q3;

        t=t+0.005;
        }
}

void MyThread::reload_PCI1713(){
    for(int i=0; i<6; i++)
        data[i]=PCI1713_3.read(i, 3);
}
